id: 0
src_id:
create_time: '2025-11-10 15:57:55.184'
time_taken: 0
states:
  - FINISHED
is_target_covered: true
new_coverage: true
newly_covered_lines: 17
is_satisfiable: false
is_crash: false
is_hang: false
usage: |
  TOTAL: {}
target_branch:
target_file_lines:
target_lines_content:
justification:
target_path_constraint:
selected_cnt: 1
successful_generation_cnt: 0
exec_code: |
  #!/usr/bin/env python3
  """
  Harness that always executes a binary with one fixed string argument.
  Compatible with ConcoLLMic's expected signature: execute_program(timeout: int).
  """

  import subprocess
  import signal
  from typing import Tuple

  def execute_program(timeout: int) -> Tuple[str, int]:
      """
      Execute the instrumented program with one string argument.
      Returns (stderr_text, return_code).
      """
      # ✅ Always run this binary (adjust path if needed)
      exe_path = "./test"

      # ✅ Always pass one string argument (change if your program needs specific format)
      arg = "AAAAAAA"

      try:
          result = subprocess.run(
              [exe_path, arg],
              capture_output=True,
              text=True,
              timeout=timeout,
          )
          return result.stderr or "", result.returncode
      except subprocess.TimeoutExpired as e:
          stderr_text = e.stderr if isinstance(e.stderr, str) else ""
          return stderr_text, -getattr(signal, "SIGKILL", 9)
      except Exception as e:
          return f"Harness error: {type(e).__name__}: {e}", -1
returncode:
src_execution_summary:
crash_info:
execution_trace: |
  [test.c] enter main 1
  [test.c] enter logic_bomb 1
  [test.c] enter logic_bomb 3
  [test.c] enter main 3
execution_summary: |2+

  ```c
  // test.c (33 lines total)
  #include <string.h> 
  #include <stdio.h>
  #include "../lib/utils.c"
  #include "../include/a_tester.h"

  int n = 5;

  // {"symvar":{"length": 256}}
  int logic_bomb(char* symvar) {
      char *p, *q;
      p = (char*)malloc(16);
      q = (char*)malloc(16);
      strcpy(p, symvar);
      free(q);
      if (n != 5){
          // Unexecuted code (lines 16-17) removed. Its line cov: 0/2 (0%)
      }else {
          free(p);
          return NORMAL_ENDING;
      }
  }

  int main(int argc, char** argv) {
      char* input = argv[1];
      int result = logic_bomb(input);
      if (result == BOMB_ENDING) {
          // Unexecuted code (line 28) removed. Its line cov: 0/1 (0%)
      } else {
          printf("Normal execution.\n");
      }
      return 0;
  }   
  ```

src_exec_code:
src_execution_trace:
