"""
This agent solves path constraints using tools (if necessary) and executes the solution
"""

from xml.sax.saxutils import unescape

from loguru import logger

from app.agents.common import (
    ExecutionInformation,
    Instructions,
    TargetPathConstraint,
    parse_tool_arguments,
)
from app.agents.tools import (
    PythonExecutorTool,
    ReviewSolveAnswerTool,
    SMTSolverTool,
    SolutionTool,
    ThinkingTool,
    process_python_executor,
    process_review_solve_answer,
    process_smt_solver,
    process_solution,
    process_thinking_tool,
)
from app.data_structures import MessageThread
from app.log import print_ace, print_solve
from app.model import common
from app.model.common import (
    Usage,
    get_usage_input_part,
    get_usage_output_part,
    init_agent_usage_details,
    update_usage_details,
)

SYSTEM_PROMPT = f"""
You are an expert in concolic execution. Your role is to solve target path constraint to generate concrete program inputs. You will be provided with:

1. **Original Execution Information**: Enclosed within `<{ExecutionInformation.__xml_tag__}>` tags, describing how the program was executed originally.
2. **Target Path Constraint**: Enclosed within `<{TargetPathConstraint.__xml_tag__}>` tags, representing the target path constraint over program input and environment that need to be satisfied. The path constraint is derived by another colleague by analyzing the original execution information and its corresponding execution trace, selecting a target branch to explore, and summarizing the constraints needed to reach it.

**IMPORTANT**: The test harness, as described in the execution information, is fixed and cannot be modified. In this context, "test harness" refers specifically to the target program itself (e.g., `target_program` in a command like `subprocess.run(["target_program", "arg1", "input_file"])`). This target program's internal code cannot be modified. However, you CAN modify all other aspects, including (but not limited to):
- Command-line arguments passed to the program
- Contents of input files
- Environment variables
- ANY other external inputs or conditions

Any solution you provide must work within the constraints of the existing test framework. You must generate inputs that can be fed into the original test harness without changing its structure or execution flow.

**Your Task**:
1. Solve the Target Path Constraint:
   - OVERALL GOAL: Generate concrete input and environment values that satisfy all constraints in the target path constraint. Express these values clearly and concisely.
   - STEPS: When facing complex constraints, adopt a divide-and-conquer approach:
     * Break down complex constraint systems into smaller, more manageable subproblems
     * Solve each subproblem independently
     * Combine these partial solutions into a comprehensive solution that satisfies all constraints
     * Verify that the combined solution doesn't violate any constraints from other subproblems
   - UNSATISFIABLE SOLUTION: If the constraints cannot be satisfied simultaneously, or if the target branch cannot be reached using the existing test harness without modifications, use the `{SolutionTool["function"]["name"]}` tool with `is_satisfiable` set to false.
   - TOOLS: optionally, if you need help to solve the constraints, you may invoke the following tools:
     - The `{SMTSolverTool["function"]["name"]}` tool solves SMT constraints using Z3 and returns variable assignments.
     - The `{PythonExecutorTool["function"]["name"]}` tool executes Python code and returns its output.
     - The `{ThinkingTool["function"]["name"]}` tool allows you to reason step-by-step about complex problems.

2. Generate Solution:
   Once you've solved the constraints, use the `{SolutionTool["function"]["name"]}` tool with:
     * `is_satisfiable` set to true
     * `python_execution` containing a complete Python function `execute_program(timeout: int) -> tuple[str, int]` that:
       - Uses the generated NEW concrete values to execute the ORIGINAL test harness
       - Includes necessary imports and setup
       - Takes a timeout to execute the program and returns a tuple with the program's (stderr, return code)

All tools are optional to use except the final `{SolutionTool["function"]["name"]}` tool, which must be used to submit your answer. DO NOT use the `{PythonExecutorTool["function"]["name"]}` tool to provide the final solution.
"""

REVIEW_SOLUTION_USER_PROMPT = f"""
We have executed your solution but determined that the target branch was not reached during execution. This discrepancy could stem from two possible sources:

(a) Your solution is incorrect - the concrete values you provided do not satisfy all the path constraints
(b) The path constraints themselves are flawed - the constraints provided to you (generated by another colleague) do not accurately represent the conditions needed to reach the target branch

To systematically troubleshoot this issue, we need to first verify your solution's correctness before questioning the constraints. Please carefully review your solution against the provided constraints and determine if it fully satisfies all requirements.

If you discover any discrepancies or errors in your solution, please indicate that the solution needs adjustment and provide a corrected solution that precisely satisfies the given constraints. Your revised solution should include concrete values for all inputs and environmental conditions specified in the constraints.

Only if your solution is mathematically correct with respect to the given constraints will we proceed to examine potential issues with the constraints themselves in the next phase.

Use the `{ReviewSolveAnswerTool["function"]["name"]}` tool to provide your review answer.
"""

CONSTRAINT_SOLVING_TEMPERATURE = 0.5


def solve(
    execution_information: str,
    target_path_constraint: str,
) -> tuple[bool, str | None, dict[str, tuple[int, Usage]], MessageThread]:
    """
    Args:
        - execution_information: information about the execution
        - target_path_constraint: constraints over the input and environment
    Returns:
        - is_satisfiable: whether constraints are satisfiable
        - python_execution: Python code to execute the program with solved inputs
        - usage_details: usage details for each tool
        - msg_thread: message thread for debugging
    """
    msg_thread = MessageThread()
    system_prompt = unescape(Instructions(instructions=SYSTEM_PROMPT).to_xml().decode())
    msg_thread.add_system(system_prompt)

    user_prompt_execution_info = unescape(
        (
            ExecutionInformation(execution_information=execution_information).to_xml()
        ).decode()
    )

    user_prompt_target_path_constraint = unescape(
        (
            TargetPathConstraint(target_path_constraint=target_path_constraint).to_xml()
        ).decode()
    )

    msg_thread.add_user(user_prompt_execution_info)
    msg_thread.add_user(
        user_prompt_target_path_constraint, clear_pre_cache_role=[]
    )  # optimize for parallel solving

    print_ace(
        user_prompt_execution_info + "\n\n" + user_prompt_target_path_constraint,
        "Path Constraint Solving",
    )

    solution_found = False
    is_satisfiable = False
    python_execution = None

    # Define available tools
    available_tools = [SolutionTool, SMTSolverTool, PythonExecutorTool, ThinkingTool]

    usage_details = init_agent_usage_details()

    last_call: list[str] = ["INITIAL"]

    initial_prompt_caching_tokens = None

    while not solution_found:
        # Call model with tools support
        response_content, response_tool_calls, usage = common.SELECTED_MODEL.call(
            msg_thread.to_msg(),
            temperature=CONSTRAINT_SOLVING_TEMPERATURE,
            tools=available_tools,
            tool_choice="auto" if available_tools else "auto",
            parallel_tool_calls=True,
        )

        if initial_prompt_caching_tokens is None:
            initial_prompt_caching_tokens = usage.cache_write_tokens
        else:
            if usage.cache_read_tokens < initial_prompt_caching_tokens:
                logger.error(
                    "The cache read tokens are less than the initial prompt caching tokens. This should not happen."
                )

        update_usage_details(usage_details, last_call, get_usage_input_part(usage))
        last_call = []

        logger.info("Solver agent response: \n{}", response_content)

        # Add model's response to the message thread
        msg_thread.add_model(response_content, response_tool_calls)

        # Check if we have tool calls to process
        if response_tool_calls:

            # Process each tool call
            for i, tool_call in enumerate(response_tool_calls):
                function_name = tool_call.get("function").get("name")
                tool_call_id = tool_call.get("id")

                last_call.append(function_name)

                logger.info(f"Solver agent calling tool `{function_name}`")

                observation = None

                # Parse arguments
                args = parse_tool_arguments(tool_call)

                if args is None:
                    observation = "Failed to parse tool call arguments."
                else:
                    # Process each type of tool call
                    if function_name == SMTSolverTool["function"]["name"]:
                        observation, _ = process_smt_solver(args.get("smt_constraints"))

                    elif function_name == PythonExecutorTool["function"]["name"]:
                        observation, _ = process_python_executor(
                            args.get("python_code")
                        )

                    elif function_name == ThinkingTool["function"]["name"]:
                        observation = process_thinking_tool(args.get("reasoning"))

                    elif function_name == SolutionTool["function"]["name"]:
                        is_sat = args.get("is_satisfiable")
                        python_exec = args.get("python_execution") if is_sat else None
                        observation, is_satisfiable, python_execution = (
                            process_solution(is_sat, python_exec)
                        )
                        if (not is_satisfiable) or (
                            is_satisfiable and python_execution
                        ):
                            solution_found = True

                msg_thread.add_tool(
                    observation,
                    name=function_name,
                    tool_call_id=tool_call_id,
                )
        else:
            msg_thread.add_user("Please use the provided tools to achieve the goal.")
            last_call.append("non_tool")

        update_usage_details(usage_details, last_call, get_usage_output_part(usage))

    logger.debug("Solve process message thread: {}", msg_thread)
    print_solve(
        f"SATISFIABLE: {is_satisfiable}\n\n"
        + (
            f"PYTHON EXECUTION: ```python\n{python_execution}\n```\n\n"
            if is_satisfiable
            else ""
        ),
        "Target Path Constraint Solving Result",
    )

    # Return the solution
    return is_satisfiable, python_execution, usage_details, msg_thread


def review_solve(
    msg_thread: MessageThread,
) -> tuple[bool, str | None, dict[str, tuple[int, Usage]], MessageThread]:
    """
    Review the solution

    Args:
        msg_thread: Message thread for the conversation
    Returns:
        need_adjust: whether the solution needs adjustment
        new_python_execution: new Python code to execute the program with solved inputs if the original solution is incorrect
        usage_details: usage details for each tool
        msg_thread: message thread for debugging
    """
    msg_thread.add_user(REVIEW_SOLUTION_USER_PROMPT)

    finished = False
    need_adjust = None
    new_python_execution = None

    # Define available tools
    available_tools = [
        ThinkingTool,
        SMTSolverTool,
        PythonExecutorTool,
        ReviewSolveAnswerTool,
    ]

    usage_details = init_agent_usage_details()

    last_call: list[str] = ["INITIAL"]

    while not finished:
        # Call model with tools support
        response_content, response_tool_calls, usage = common.SELECTED_MODEL.call(
            msg_thread.to_msg(),
            temperature=CONSTRAINT_SOLVING_TEMPERATURE,
            tools=available_tools,
            tool_choice="auto" if available_tools else "auto",
            parallel_tool_calls=True,
        )
        update_usage_details(usage_details, last_call, get_usage_input_part(usage))
        last_call = []

        logger.debug(
            "Target path constraint solving call response: \n{}", response_content
        )

        # Add model's response to the message thread
        msg_thread.add_model(response_content, response_tool_calls)

        # Check if we have tool calls to process
        if response_tool_calls:

            # Process each tool call
            for i, tool_call in enumerate(response_tool_calls):
                function_name = tool_call.get("function").get("name")
                tool_call_id = tool_call.get("id")

                last_call.append(function_name)

                observation = None

                # Parse arguments
                args = parse_tool_arguments(tool_call)

                if args is None:
                    observation = "Failed to parse tool call arguments."
                else:
                    # Process each type of tool call
                    if function_name == SMTSolverTool["function"]["name"]:
                        observation, _ = process_smt_solver(args.get("smt_constraints"))

                    elif function_name == PythonExecutorTool["function"]["name"]:
                        observation, _ = process_python_executor(
                            args.get("python_code")
                        )

                    elif function_name == ThinkingTool["function"]["name"]:
                        observation = process_thinking_tool(args.get("reasoning"))

                    elif function_name == ReviewSolveAnswerTool["function"]["name"]:
                        need_adjust = args.get("need_adjust")
                        observation, need_adjust, new_python_execution = (
                            process_review_solve_answer(
                                need_adjust,
                                (
                                    args.get("new_python_execution")
                                    if need_adjust
                                    else None
                                ),
                            )
                        )
                        assert need_adjust == (
                            args.get("need_adjust")
                            if args.get("need_adjust") is not None
                            else True
                        )
                        if (not need_adjust) or (
                            need_adjust and (new_python_execution is not None)
                        ):
                            finished = True

                msg_thread.add_tool(
                    observation,
                    name=function_name,
                    tool_call_id=tool_call_id,
                )
        else:
            msg_thread.add_user("Please use the provided tools to achieve the goal.")
            last_call.append("non_tool")

        update_usage_details(usage_details, last_call, get_usage_output_part(usage))

    logger.debug("Review answer message thread: {}", msg_thread)
    print_solve(
        f"NEED ADJUST: {need_adjust}"
        + (
            f"\n\nNEW PYTHON EXECUTION: ```python\n{new_python_execution}\n```\n\n"
            if need_adjust
            else ""
        ),
        "Review Solution Result",
    )

    # Return the solution
    assert need_adjust is not None
    return need_adjust, new_python_execution, usage_details, msg_thread
