id: 0
src_id:
create_time: '2025-11-13 11:55:20.947'
time_taken: 0
states:
  - FINISHED
is_target_covered: true
new_coverage: true
newly_covered_lines: 39
is_satisfiable: false
is_crash: false
is_hang: false
usage: |
  TOTAL: {}
target_branch:
target_file_lines:
target_lines_content:
justification:
target_path_constraint:
selected_cnt: 1
successful_generation_cnt: 1
exec_code: |
  def execute_program(timeout: int) -> tuple[str, int]:
      import signal
      import subprocess

      try:
          result = subprocess.run(
              ["./count 1.0 1.00001"],
              capture_output=True,
              encoding="utf-8",
              errors="replace",
              shell=True,
              timeout=timeout,
          )
          # Return stderr and the return code
          return result.stderr, result.returncode
      except subprocess.TimeoutExpired as e:
          # Timeout occurred, also ensure to return stderr captured before timeout and return code -signal.SIGKILL
          return e.stderr, -signal.SIGKILL
      except Exception as e:
          # ensure to raise the error if run failed
          raise e
returncode:
src_execution_summary:
crash_info:
execution_trace: |
  [count.c] enter main 1
  [count.c] enter main 3
  [count.c] enter main 5
  [count.c] enter main 7
  [count.c] enter main 9
  [count.c] enter main 11
  [count.c] enter main 12
  [count.c] enter main 12
  [count.c] enter main 12
  [count.c] enter main 12
  [count.c] enter main 12
  [count.c] enter main 12
  [count.c] enter main 12
  [count.c] enter main 12
  [count.c] enter main 12
  [count.c] enter main 12
  [count.c] enter main 12
  [count.c] enter main 12
  [count.c] enter main 12
  [count.c] enter main 12
  [count.c] enter main 12
  [count.c] enter main 12
  [count.c] enter main 12
  [count.c] enter main 12
  [count.c] enter main 12
  [count.c] enter main 12
  [count.c] enter main 12
  [count.c] enter main 12
  [count.c] enter main 12
  [count.c] enter main 12
  [count.c] enter main 12
  [count.c] enter main 12
  [count.c] enter main 12
  [count.c] enter main 12
  [count.c] enter main 12
  [count.c] enter main 12
  [count.c] enter main 12
  [count.c] enter main 12
  [count.c] enter main 12
  [count.c] enter main 12
  [count.c] enter main 12
  [count.c] enter main 12
  [count.c] enter main 12
  [count.c] enter main 12
  [count.c] enter main 12
  [count.c] enter main 12
  [count.c] enter main 12
  [count.c] enter main 12
  [count.c] enter main 12
  [count.c] enter main 12
  [count.c] enter main 12
  [count.c] enter main 12
  [count.c] enter main 12
  [count.c] enter main 12
  [count.c] enter main 12
  [count.c] enter main 12
  [count.c] enter main 12
  [count.c] enter main 12
  [count.c] enter main 12
  [count.c] enter main 12
  [count.c] enter main 12
  [count.c] enter main 12
  [count.c] enter main 12
  [count.c] enter main 12
  [count.c] enter main 12
  [count.c] enter main 12
  [count.c] enter main 12
  [count.c] enter main 12
  [count.c] enter main 12
  [count.c] enter main 12
  [count.c] enter main 12
  [count.c] enter main 12
  [count.c] enter main 12
  [count.c] enter main 12
  [count.c] enter main 12
  [count.c] enter main 12
  [count.c] enter main 12
  [count.c] enter main 12
  [count.c] enter main 12
  [count.c] enter main 12
  [count.c] enter main 12
  [count.c] enter main 12
  [count.c] enter main 12
  [count.c] enter main 12
  [count.c] enter main 12
  [count.c] enter main 12
  [count.c] enter main 12
  [count.c] enter main 12
  [count.c] enter main 12
  [count.c] enter main 12
  [count.c] enter main 13
execution_summary: |2+

  ```c
  // count.c (72 lines total)
  #include <assert.h>
  #include <string.h>
  #include <math.h>
  #include <stdio.h>
  #include <stdlib.h>

  #define START_FLOAT 1.0f
  #define END_FLOAT 1.00001f
  #define FLOATS_BETWEEN_BUG 20
  #define FLOATS_BETWEEN_MAX 84

  int main(int argc, char** argv) {
    // The program counts all floats between start (inclusive) and end (exclusive)
    float start;
    float end;

    if (argc != 3) {
      // Unexecuted code (lines 18-19) removed. Its line cov: 0/2 (0%)
    }
    
    start = atof(argv[1]);
    end = atof(argv[2]);

    // We constrain the bounds to be numbers, ordered, and within the
    // range [START_FLOAT, END_FLOAT].  As a result, FLOATS_BETWEEN
    // gives a bound on the number of single-precision floating-point
    // numbers that lie in between these bounds.

    if(isnan(start) || isnan(end)) {
      // Unexecuted code (line 31) removed. Its line cov: 0/1 (0%)
    }

    if(start > end) {
      // Unexecuted code (line 35) removed. Its line cov: 0/1 (0%)
    }
   
    if(start < START_FLOAT) {
      // Unexecuted code (line 39) removed. Its line cov: 0/1 (0%)
    }

    if(end > END_FLOAT) {
      // Unexecuted code (line 43) removed. Its line cov: 0/1 (0%)
    }

    int count = 0;
    
    // We require that unsigned and float have the same size for the
    // program to operate correctly
    assert(sizeof(unsigned) == sizeof(float));

    // Iterate through the floating-point numbers in the range by
    // bit-conversion to unsigned.
    for(float current = start; current != end; count++) {
      unsigned temp;
      memcpy(&temp, &current, sizeof(float));
      temp++;
      memcpy(&current, &temp, sizeof(float));
    }

    // Check that the count is non-negative and bounded above by
    // FLOATS_BETWEEN
    printf("Count is %d\n", count);
    assert(count >= 0);
    assert(FLOATS_BETWEEN_MAX);
    if (count <= FLOATS_BETWEEN_BUG) {
      // Unexecuted code (lines 67-68) removed. Its line cov: 0/2 (0%)
    }
    
    return 0;
  }
  ```

src_exec_code:
src_execution_trace:
