id: 3
src_id: 1
create_time: '2025-11-18 21:44:43.858'
time_taken: 375
states:
  - SELECT
  - SUMMARIZE
  - SOLVE
  - EXECUTE
  - FINISHED
is_target_covered: true
new_coverage: true
newly_covered_lines: 2
is_satisfiable: true
is_crash: true
is_hang: false
usage: |
  TOTAL:
    model: deepseek-chat
    cost: $0.02436480
    call_cnt: 5
    latency: 59.61s
    input_tokens: 24974
    output_tokens: 1475
    cache_read_tokens: 0
    cache_write_tokens: 0
  SELECT:
    TOTAL: {}
  SUMMARIZE:
    TOTAL:
      model: deepseek-chat
      cost: $0.01766280
      call_cnt: 3
      latency: 34.77s
      input_tokens: 19184
      output_tokens: 720
      cache_read_tokens: 0
      cache_write_tokens: 0
    INITIAL:
      model: deepseek-chat
      cost: $0.00498300
      call_cnt: 0
      latency: 0.00s
      input_tokens: 0
      output_tokens: 0
      cache_read_tokens: 0
      cache_write_tokens: 0
    think:
      model: deepseek-chat
      cost: $0.00641130
      call_cnt: 1
      latency: 14.65s
      input_tokens: 6040
      output_tokens: 421
      cache_read_tokens: 0
      cache_write_tokens: 0
    select_target_branch:
      model: deepseek-chat
      cost: $0.00591915
      call_cnt: 1
      latency: 12.14s
      input_tokens: 6470
      output_tokens: 162
      cache_read_tokens: 0
      cache_write_tokens: 0
    generate_path_constraint:
      model: deepseek-chat
      cost: $0.00034935
      call_cnt: 1
      latency: 7.98s
      input_tokens: 6674
      output_tokens: 137
      cache_read_tokens: 0
      cache_write_tokens: 0
  SOLVE:
    TOTAL:
      model: deepseek-chat
      cost: $0.00670200
      call_cnt: 2
      latency: 24.84s
      input_tokens: 5790
      output_tokens: 755
      cache_read_tokens: 0
      cache_write_tokens: 0
    INITIAL:
      model: deepseek-chat
      cost: $0.00220358
      call_cnt: 0
      latency: 0.00s
      input_tokens: 0
      output_tokens: 0
      cache_read_tokens: 0
      cache_write_tokens: 0
    think:
      model: deepseek-chat
      cost: $0.00369263
      call_cnt: 1
      latency: 15.73s
      input_tokens: 2671
      output_tokens: 439
      cache_read_tokens: 0
      cache_write_tokens: 0
    provide_solution:
      model: deepseek-chat
      cost: $0.00080580
      call_cnt: 1
      latency: 9.11s
      input_tokens: 3119
      output_tokens: 316
      cache_read_tokens: 0
      cache_write_tokens: 0
  EXECUTE:
    TOTAL: {}
target_branch: if (argc < 2) -> true in aes_cf_klee.c:main
target_file_lines: aes_cf_klee.c:66-67
target_lines_content: |2-
          fprintf(stderr, "Usage: %s <input-string>\n", argv[0]);
          return 2;
justification: This branch has 0% historical coverage (0/2 lines) and represents an
  important input validation path. It tests the program's behavior when insufficient
  command-line arguments are provided. While it's a simple error handling branch,
  it's currently untested and could reveal issues with the program's error reporting
  or handling of malformed inputs.
target_path_constraint: |-
  To reach the target branch (argc < 2 -> true in main function):

  1. Command-Line Arguments: The program must be executed with fewer than 2 command-line arguments. Specifically:
     - argc == 1 (only the program name itself, no additional arguments)
     - argv[1] must not be provided

  This single constraint is sufficient to trigger the branch, as the program will immediately check if argc < 2 and execute the error handling code if this condition is true.
selected_cnt: 1
successful_generation_cnt: 0
exec_code: |-
  def execute_program(timeout: int) -> tuple[str, int]:
      import signal
      import subprocess

      try:
          # Execute with only 1 argument (just the program name) to satisfy argc < 2
          result = subprocess.run(
              ["./temp_executable"],  # Only the program name, no additional arguments
              capture_output=True,
              encoding="utf-8",
              errors="replace",
              shell=False,
              timeout=timeout,
          )
          # Return stderr and the return code
          return result.stderr, result.returncode
      except subprocess.TimeoutExpired as e:
          # Timeout occurred, also ensure to return stderr captured before timeout and return code -signal.SIGKILL
          stderr_text = e.stderr.decode("utf-8", errors="replace") if e.stderr else ""
          return stderr_text, -signal.SIGKILL
      except Exception as e:
          # ensure to raise the error if run failed
          raise e
returncode: 2
src_execution_summary: |2+

  ```c
  // aes_cf_klee.c (72 lines total)
  #include <stdio.h>
  /*
  TOY:
  */
  #include <inttypes.h>
  #include "aes.h"
  #include "utils.h"

  void aes_print(uint8_t* str) {
      // Unexecuted code (lines 10-13) removed. Its line cov: 0/4 (0%)
  }

  #include "a_tester.h"

  // {"s":{"length": 32}}
  int logic_bomb(char* s) {
      if(strlen(s) != 32){
          // Unexecuted code (lines 21-23) removed. Its line cov: 3/3 (100%)
      }

      uint8_t key[16];

      sscanf(s,
          "%2" SCNx8 "%2" SCNx8
          "%2" SCNx8 "%2" SCNx8
          "%2" SCNx8 "%2" SCNx8
          "%2" SCNx8 "%2" SCNx8
          "%2" SCNx8 "%2" SCNx8
          "%2" SCNx8 "%2" SCNx8
          "%2" SCNx8 "%2" SCNx8
          "%2" SCNx8 "%2" SCNx8,
          &key[0],&key[1],
          &key[2],&key[3],
          &key[4],&key[5],
          &key[6],&key[7],
          &key[8],&key[9],
          &key[10],&key[11],
          &key[12],&key[13],
          &key[14],&key[15]);

      //aes_print(key);

      uint8_t decodetext[16];
      uint8_t ciphertext[] = {0x3a, 0xd7, 0x7b, 0xb4, 0x0d, 0x7a, 0x36, 0x60, 0xa8, 0x9e, 0xca, 0xf3, 0x24, 0x66, 0xef, 0x97};
      uint8_t plaintext[] = {0x6b, 0xc1, 0xbe, 0xe2, 0x2e, 0x40, 0x9f, 0x96, 0xe9, 0x3d, 0x7e, 0x11, 0x73, 0x93, 0x17, 0x2a};

      AES128_ECB_decrypt(ciphertext, key, decodetext);

      //aes_print(decodetext);
      if(0 == memcmp((char*) plaintext, (char*) decodetext, 16)){
          // Unexecuted code (lines 56-57) removed. Its line cov: 2/2 (100%)
      }else{
          fprintf(stderr, "Path without the bomb\n");
          return 0;
      }
  }

  int main(int argc, char **argv) {
      if (argc < 2) {
          // Unexecuted code (lines 66-67) removed. Its line cov: 0/2 (0%)
      }

      char *s = argv[1];
      return logic_bomb(s);
  }
  ```

crash_info: |
  Crash reason: Segmentation fault
  Stderr:
  Usage: ./temp_executable <input-string>
execution_trace: |
  [aes_cf_klee.c] enter main 1
  [aes_cf_klee.c] enter main 2
  Usage: ./temp_executable <input-string>
execution_summary: |2+

  ```c
  // aes_cf_klee.c (72 lines total)
  #include <stdio.h>
  /*
  TOY:
  */
  #include <inttypes.h>
  #include "aes.h"
  #include "utils.h"

  void aes_print(uint8_t* str) {
      // Unexecuted code (lines 10-13) removed. Its line cov: 0/4 (0%)
  }

  #include "a_tester.h"

  // {"s":{"length": 32}}
  int logic_bomb(char* s) {
      // Unexecuted code (lines 20-61) removed. Its line cov: 36/36 (100%)
  }

  int main(int argc, char **argv) {
      if (argc < 2) {
          fprintf(stderr, "Usage: %s <input-string>\n", argv[0]);
          return 2;
      }

      // Unexecuted code (lines 70-71) removed. Its line cov: 2/2 (100%)
  }
  ```

src_exec_code: |-
  def execute_program(timeout: int) -> tuple[str, int]:
      import signal
      import subprocess

      # Generate a valid 32-character hexadecimal string
      hex_chars = '0123456789abcdef'
      hex_string = '55966374aa56a0aa46853de7780f7723'  # Valid 32-char hex string

      try:
          # Execute with proper argument separation (executable and argument as separate list elements)
          result = subprocess.run(
              ["./temp_executable", hex_string],  # Separate executable and argument
              capture_output=True,
              encoding="utf-8",
              errors="replace",
              shell=False,  # Set to False to properly handle list arguments
              timeout=timeout,
          )
          # Return stderr and the return code
          return result.stderr, result.returncode
      except subprocess.TimeoutExpired as e:
          # Timeout occurred, also ensure to return stderr captured before timeout and return code -signal.SIGKILL
          stderr_text = e.stderr.decode("utf-8", errors="replace") if e.stderr else ""
          return stderr_text, -signal.SIGKILL
      except Exception as e:
          # ensure to raise the error if run failed
          raise e
src_execution_trace: |
  [aes_cf_klee.c] enter main 1
  [aes_cf_klee.c] enter main 3
  [aes_cf_klee.c] enter logic_bomb 1
  [aes_cf_klee.c] enter logic_bomb 3
  [aes_cf_klee.c] enter logic_bomb 5
  Path without the bomb
